//
//  SearchStationsInteractor.swift
//  TrainTicketMachine
//
//  Created by JoÃ£o Gameiro on 28/03/18.
//  Copyright (c) 2018 JG.com. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SearchStationsBusinessLogic {
    func fetchStationsList(request: SearchStations.FetchStationsList.Request)
    func filterStationsList(request:SearchStations.FilterStationsList.Request)
    func matchingLettersList(request:SearchStations.MatchingLettersForFilteredResults.Request)
}

protocol SearchStationsDataStore {
    var stations: [Station]? { get }
}

class SearchStationsInteractor: SearchStationsBusinessLogic, SearchStationsDataStore {
    var presenter: SearchStationsPresentationLogic?
    var worker: SearchStationsWorker?
    var stations: [Station]?
    var filteredStations: [SearchStations.FetchStationsList.ViewModel.DisplayedStation]!
    var matchingLettersForResults: [String] = []
    
    // MARK: Fetch Stations List
    
    /**
     Fetches the list of all available stations and send the response to the presenter.
     */
    func fetchStationsList(request: SearchStations.FetchStationsList.Request) {
        worker = SearchStationsWorker()
        self.stations = worker?.fetchStationsList()
        
        let response = SearchStations.FetchStationsList.Response.init(stations: stations!)
        presenter?.presentStationsList(response: response)
    }
    // MARK: Filter Stations List
    
    /**
     Filters the list of all available stations using the input text and sends the matching stations as response to the presenter.
     */
    func filterStationsList(request:SearchStations.FilterStationsList.Request) {
        self.filteredStations = request.stationsList.filter{ station in
            
            if station.name.first == request.textInput.first {
                return station.name.uppercased().contains(request.textInput.uppercased())
            }
            return false
        }
        let response = SearchStations.FilterStationsList.Response.init(filteredStations: self.filteredStations)
        presenter?.presentFilteredStationsList(response: response)
    }
    // MARK: Get List of Matching Letters For Filtered Stations
    /**
     Searches each result in the filtered stations to get the next letter in the string. Sends the list of next letters to the presenter.
     */
    func matchingLettersList(request: SearchStations.MatchingLettersForFilteredResults.Request) {
        matchingLettersForResults.removeAll()
        var matchingLetterList = [String]()
        //Uses the input text  count to get the index of the next character in the string. After getting the character converts it back to string and appends it to the list of matching letters.
        for result in request.filteredResults {
            let indexStartOfText = result.name.index(result.name.startIndex, offsetBy: request.textToTrim.count)
            let substring = result.name[indexStartOfText]
            matchingLetterList.append(String(substring))
        }
        //Verify if the list has more then 1 element. It's not necessary to show results if there isn't more than 1 element.
        if matchingLetterList.count > 1 {
            matchingLettersForResults.insert(contentsOf: matchingLetterList, at: 0)
        }
        let response = SearchStations.MatchingLettersForFilteredResults.Response.init(matchingLettersList: matchingLettersForResults)
        presenter?.presentMatchingLettersForResultsList(response: response)
    }
}
